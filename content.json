[{"title":"移动端input框图片旋转","date":"2020-04-26T06:18:36.000Z","path":"2020/04/26/移动端input框图片旋转/","text":"问题描述使用 input 进行图片上传，上传后的图片会旋转 90 度。 解决方案 使用 EXIF 库来判断上传的图片是否需要旋转 将图片转换成 base64 后使用 canvas 进行旋转 根据需求再将 base64 转换成 file 类型 详细步骤 安装 exif 库 npm install exif-js -D 判断图片是否需要旋转。EXIF 中，包含一个 Orientation 参数，用来记录拍摄照片时的方向。 Orientation 含义 1 正常 2 正常镜像 3 顺时针旋转 180° 4 顺时针旋转 180° 镜像 5 顺时针旋转 270° 镜像 6 顺时针旋转 270° 7 顺时针旋转 90° 镜像 8 顺时针旋转 90° 123456789101112131415// 获取图片信息，判断是否旋转isNeedFixPhoto = (file) =&gt; &#123; return new Promise(function (resolve, reject) &#123; Exif.getData(file, function () &#123; let Orientation = Exif.getTag(this, 'Orientation'); if (Orientation &amp;&amp; Orientation !== 1) &#123; //图片角度不正确 resolve(&#123; flag: true, Orientation &#125;); &#125; else &#123; //不需处理直接上传 resolve(&#123; flag: false, Orientation &#125;); &#125; &#125;); &#125;);&#125;; 将图片转成 base64 12345678910// 图片转base64file2Base64 = (file) =&gt; &#123; return new Promise(function (resolve, reject) &#123; let reader = new FileReader(); reader.readAsDataURL(file); reader.onload = function (ev) &#123; resolve(ev.target.result); &#125;; &#125;);&#125;; 对图片进行旋转处理 1234567891011121314151617181920212223242526272829303132333435363738394041// 旋转处理图片best4Photo = (resultBase64, Orientation, num, w) =&gt; &#123; return new Promise(function (resolve, reject) &#123; let image = new Image(); image.src = resultBase64; image.onload = function () &#123; let imgWidth = w, imgHeight = (w * this.height) / this.width; //获取图片宽高 let canvas = document.createElement('canvas'); let ctx = canvas.getContext('2d'); canvas.width = imgWidth; canvas.height = imgHeight; if (Orientation &amp;&amp; Orientation !== 1) &#123; switch (Orientation) &#123; case 6: // 旋转90度 canvas.width = imgHeight; canvas.height = imgWidth; ctx.rotate(Math.PI / 2); ctx.drawImage(this, 0, -imgHeight, imgWidth, imgHeight); break; case 3: // 旋转180度 ctx.rotate(Math.PI); ctx.drawImage(this, -imgWidth, -imgHeight, imgWidth, imgHeight); break; case 8: // 旋转-90度 canvas.width = imgHeight; canvas.height = imgWidth; ctx.rotate((3 * Math.PI) / 2); ctx.drawImage(this, -imgWidth, 0, imgWidth, imgHeight); break; default: break; &#125; &#125; else &#123; ctx.drawImage(this, 0, 0, imgWidth, imgHeight); &#125; const result = canvas.toDataURL('image/jpeg', num); resolve(result); &#125;; &#125;);&#125;; 最终执行方法 1234567891011121314// 图片修正repairPhoto = async (file, num, w) =&gt; &#123; const result = await isNeedFixPhoto(file); const resultBase64 = await file2Base64(file); const Orientation = result.Orientation; const numb = num || 1; if (result.flag) &#123; // 处理旋转 return await best4Photo(resultBase64, Orientation, numb, w); &#125; else &#123; // 不处理旋转 return await best4Photo(resultBase64, 1, numb, w); &#125;&#125;; base64 转 file 123456789101112// base64转fileexport const base64URLtoFile = (base64Data, filename) =&gt; &#123; let arr = base64Data.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123; type: mime &#125;);&#125;;","tags":[]},{"title":"mobx问题记录","date":"2019-09-10T02:29:35.000Z","path":"2019/09/10/mobx问题记录/","text":"安装（基于 create-react-app） npm 安装 npm install mobx mobx-react -D 使用装饰器 由于 babel 的更新，解决浏览器无法识别装饰器的解决方案为安装npm install @babel/plugin-proposal-decorators -D，然后在package.json中添加 12345678910\"babel\": &#123; \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125; ] ],&#125; 使用示例 123456789101112131415161718192021222324252627282930import React from \"react\";import &#123; observable &#125; from \"mobx\";import &#123; observer &#125; from \"mobx-react/custom\"; // 注意，如果写成import &#123; observer &#125; from \"mobx-react\" 会报错import styles from \"./index.module.less\";@observerclass MobxTest extends React.Component &#123; @observable count = 0; handleAdd = () =&gt; &#123; this.count++; &#125;; handleDelete = () =&gt; &#123; this.count--; &#125;; render() &#123; return ( &lt;div className=&#123;styles.container&#125;&gt; &lt;span onClick=&#123;this.handleAdd&#125;&gt;增加&lt;/span&gt; &#123;this.count&#125; &lt;span onClick=&#123;this.handleDelete&#125;&gt;减少&lt;/span&gt; &lt;/div&gt; ); &#125;&#125;export default MobxTest;","tags":[]},{"title":"node文件操作","date":"2019-08-06T08:04:07.000Z","path":"2019/08/06/node文件操作/","text":"引入 fs 文件模块即可使用 1const fs = require(\"fs\"); 文件读取第二个参数表示编码格式，若未指定，则 data 为原始 buffer 1234567fs.readFile(\"1.txt\", \"utf-8\", (err, data) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); // 文件内容，string类型 &#125;&#125;); 文件写入文件重写12345678const data = \"重写内容\";fs.writeFile(\"1.txt\", data, err =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(\"写入成功\"); // 文件内容，string类型 &#125;&#125;); 文件内容追加（在内容末尾添加）12345678const data = \"重写内容\";fs.appendFile(\"1.txt\", data, err =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(\"写入成功\"); // 文件内容，string类型 &#125;&#125;); 在指定位置添加内容 思路：先使用 readFile 方法读取文件内容，由于读取的内容是 string 类型且有换行，因此可以通过 split 方法，以换行符为分割，将内容字符串分割成一个数组，在使用数组的 splice 方法将要添加的内容添加到指定位置，在将添加内容后的数据通过 join 方法组合成字符串，最后使用 writeFile 方法重写文件。 代码： 123456789101112131415fs.readFile(\"1.txt\", \"utf-8\", (err, data) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; let newData = data.split(/\\r\\n|\\n|\\r/gm); // 以换行符分割成数组 newData.splice(2, 0, \"添加的内容\"); fs.writeFile(\"1.txt\", newData.join(\"\\r\\n\"), err =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(\"添加成功\"); &#125; &#125;); &#125;&#125;); 文件重命名1234567fs.rename(\"1.txt\", \"2.js\", err =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(\"修改成功\"); &#125;&#125;); 文件删除1234567fs.unlink(\"1.txt\", err =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(\"删除成功\"); &#125;&#125;); 获取文件夹文件列表12345fs.readdir(\"./\", (err, file) =&gt; &#123; file.forEach(item =&gt; &#123; console.log(item); // item为文件名，包括文件夹，带文件类型 &#125;);&#125;); 新建文件夹1234567fs.mkdir(\"test\", err =&gt; &#123; if (err) &#123; console.log(\"创建失败\"); &#125; else &#123; console.log(\"创建成功\"); &#125;&#125;);","tags":[]},{"title":"移动端授权及支付","date":"2019-08-01T06:26:40.000Z","path":"2019/08/01/移动端授权及支付/","text":"微信授权（获取 code）h5 授权 在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名，域名不需要加 http 判断路由参数中是否有 code，没有则跳转授权页面，页面路由https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxbfe4d93e70cd3bd5&amp;redirect_uri=redirect_uri&amp;response_type=code&amp;scope=snsapi_userinfo#wechat_redirect。其中 Appid 和 redirect_uri 需要根据项目填写 用户同意授权后跳转至 redirect_uri 指定页面，路由中会有 code 参数。 pc 端内嵌扫码授权 同 h5 授权，也需要在公众平台设置回调域名 在 index.html 中引入http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js 在需要使用微信登录的地方实例以下 JS 对象： 12345678910const obj = new WxLogin(&#123; self_redirect: false, // 设置为true表示在iframe中跳转至redirect_uri id: \"login_container\", // 二维码容器id appid: \"\", // 应用标识 scope: \"snsapi_login\", // 这里填snsapi_login redirect_uri: \"\", // 回调地址 state: \"\", style: \"\", href: \"\"&#125;); pc 跳转页面扫码授权 配置回调域名 授权页面链接https://open.weixin.qq.com/connect/qrconnect?appid=appid&amp;redirect_uri=redirect_uri&amp;response_type=code&amp;scope=snsapi_login&amp;state=STATE#wechat_redirect。其中 Appid 和 redirect_uri 需要根据项目填写，redirect_uri 需要使用 urlEncode 进行处理 小程序授权 授权窗口的弹出必须由用户点击按钮来触发 按钮代码&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;bindGetUserInfo&quot; /&gt;，如果用户同意授权，通过 bindGetUserInfo 中的参数 e 可以获取用户相关信息 微信公众号支付（包括在微信内的 h5）有 2 种方式，JSSDK 和 JSAPI（微信内置对象 WeixinJSBridge），推荐使用微信浏览器内置对象 WeixinJSBridge 来进行支付。 JSAPI，微信浏览器内置对象 WeixinJSBridge（推荐使用） 12345678910111213141516171819202122232425262728293031323334function onBridgeReady() &#123; // data为后台返参数据 window.WeixinJSBridge.invoke( \"getBrandWCPayRequest\", &#123; appId: data.appId, // 公众号的唯一标识 timeStamp: data.timeStamp, // 生成签名的时间戳 nonceStr: data.nonceStr, // 生成签名的随机串 package: data.packageValue, // 统一支付接口返回的prepay_id参数值 signType: data.signType, // 签名方式 paySign: data.sign // 支付签名 &#125;, function(response) &#123; if ( response.err_msg === \"get_brand_wcpay_request：ok\" || response.err_msg.search(\"ok\") !== -1 ) &#123; // 支付成功的回调 &#125; else &#123; // 支付失败的回调 &#125; &#125; );&#125;if (typeof window.WeixinJSBridge == \"undefined\") &#123; if (document.addEventListener) &#123; document.addEventListener(\"WeixinJSBridgeReady\", onBridgeReady, false); &#125; else if (document.attachEvent) &#123; document.attachEvent(\"WeixinJSBridgeReady\", onBridgeReady); document.attachEvent(\"onWeixinJSBridgeReady\", onBridgeReady); &#125;&#125; else &#123; onBridgeReady();&#125; JSSDK 首先需要引入 js 文件 1234&lt;script type=\"text/javascript\" src=\"http://res.wx.qq.com/open/js/jweixin-1.0.0.js\"&gt;&lt;/script&gt; 其次需要使用微信的 config 接口注入权限验证配置，代码如下: 12345678wx.config(&#123; debug: true, // 开启调试模式 appId: appId, // 公众号的唯一标识 timestamp: timestamp, // 生成签名的时间戳 nonceStr: nonceStr, // 生成签名的随机串 signature: signature, // 签名 jsApiList: [\"chooseWXPay\"] // 填入需要使用的JS接口列表，这里只需要用到支付的JS接口&#125;); 验证成功后再调用支付 12345678wx.chooseWXPay(&#123; timestamp: timestamp, // 支付签名时间戳 nonceStr: nonceStr, // 支付签名随机串，不长于 32 位 package: package, // 统一支付接口返回的prepay_id参数值 signType: signType, // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5' paySign: paySign, // 支付签名 success: function(res) &#123;&#125;&#125;); 微信 h5 支付（在微信浏览器外的浏览器内支付）功能主要由后台来实现，后台会返回一个链接，前台只需调用接口即可，成功和失败的回调由后端进行配置 小程序支付12345678910wx.requestPayment(&#123; timeStamp: \"\", // 支付签名时间戳 nonceStr: \"\", // 支付签名随机串，不长于 32 位 package: \"\", // 统一支付接口返回的prepay_id参数值 signType: \"MD5\", // 默认为MD5 paySign: \"\", // 支付签名 success(res) &#123;&#125;, // 成功回调 fail(res) &#123;&#125;, // 失败回调 complete(res) &#123;&#125; // 结束回调&#125;); 支付宝支付接口会返回一个 form 表单类似下图所示，前端只需提交这个表单即可，成功和失败的回调由后端进行配置 方法一： 1window.document.write(payRes); //payRes即为form表单 方法二： 1234const div = document.createElement(\"div\"); // 创建divdiv.innerHTML = payRes; // 将返回的form 放入divdocument.body.appendChild(div);document.forms[0].submit(); 注意事项 微信 h5 支付和公众号支付均需要在公众平台开通支付功能 配置公众号支付路由时，需要将一个认证文件放到项目根目录的 public 文件夹中，认证文件由产品提供 只需将正式服和测试服域名进行配置，以/结尾，不需要单独将要支付的页面路由进行单独配置，如下图所示即可","tags":[]},{"title":"margin折叠","date":"2019-07-12T02:48:33.000Z","path":"2019/07/12/margin折叠/","text":"什么是 margin 折叠在 CSS 中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。 父子间： 兄弟间：、 什么时候发生 margin 折叠 没有被 padding、border、clear 和 line box 分隔开 属于同一个 BFC（块级格式化上下文 ） 垂直方向 属于普通流 如何形成一个 BFC1、float 的值不是 none。（float:left 或者 float:right） 2、position 的值不是 static 或者 relative。（position:absolute 或者 position:fixed） 3、display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex 4、overflow 的值不是 visible（overflow:hidden、overflow:scroll） 5、父元素与正常文件流的子元素（非浮动子元素）自动形成一个 BFC 解决方案 父子间 父元素设置以下属性中的一种： 12345/* padding-top: 1px; *//* overflow: hidden; *//* border-top: 1px solid red; *//* display: inline-block; *//* display: table-cell; */ 兄弟间 推荐使用 padding 来代替 margin 使用 将兄弟元素分别作为子元素放在块级元素内，然后将其父级元素的渲染规则该为 BFC","tags":[]},{"title":"antd踩过的坑","date":"2019-07-02T03:40:55.000Z","path":"2019/07/02/antd踩过的坑/","text":"react antd 踩过的坑 Select,Cascader,Datepicker 的下拉框随着页面的滚动而滚动 原因：下拉框默认相对于页面 body 定位 解决方案：让下拉框相对于父级元素定位即可 Select,Cascader 1getPopupContainer=&#123;trigger =&gt; trigger.parentNode&#125; Datepicker 1getCalendarContainer=&#123;trigger =&gt; trigger.parentNode&#125;","tags":[]},{"title":"ts学习笔记","date":"2019-06-26T02:06:42.000Z","path":"2019/06/26/ts学习笔记/","text":"数据类型 类型推论。 1let myFavoriteNumber = \"seven\"; 等价于 1let myFavoriteNumber: string = \"seven\"; ts 会在没有明确的指定类型的时候推测出一个类型。但是，如果定义的时候没有赋值，不管之后 有没有赋值，都会被推断成 any 类型而完全不被类型检查。 12let myFavoriteNumber;myFavoriteNumber = \"seven\"; 等价于 12let myFavoriteNumber: any;myFavoriteNumber = \"seven\"; 接口（interface） 自定义属性 1234567891011interface Person &#123; name: string; age?: number; [x: string]: string;&#125;let tom: Person = &#123; name: \"Tom\", age: 25, gender: \"male\"&#125;; 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集，上面代码中定义了任意属性，而 age 的值却是 number，number 不是 string 的子属性，所以编译会报错","tags":[]},{"title":"Hello World","date":"2019-06-20T06:16:15.656Z","path":"2019/06/20/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"电商流程","date":"2019-06-20T03:50:21.000Z","path":"2019/06/20/电商流程/","text":"一、普通订单状态 待付款 待发货 待收货 交易完成 交易关闭 注意： 功能条目中的内容只在订单详情页展示，列表页不展示。 按钮条目是有顺序的，若未特殊说明，从上到下依次对应 ui 中从右往左。 联系客服这个按钮不在按钮列表显示，统一加在订单详情页面内容中。 状态流转是指该状态之后一步的状态。 待付款 功能 支付倒计时（默认 30 分钟） 按钮 立即支付（高亮） 修改地址（根据产品需求添加） 取消订单 状态流转 交易关闭（取消订单后流转） 待发货（支付成功后流转） 详情展示内容 用户地址信息 各种商品信息（图片，名称，规格，单价，数量） 商品总金额 优惠金额 积分抵扣金额 运费 订单实付金额 订单编号 下单时间 备注 待发货 功能 无 按钮 批量退款（仅退款，点击后底部出个弹窗，弹窗内容为商品列表，用于勾选需要退款的商品，选完提交后跳转表单页面，在表单页面不显示选择退款的方式） 状态流转 待收货（商家发货后流转） 详情展示内容 用户地址信息 各种商品信息（图片，名称，规格，单价，数量） 商品总金额 优惠金额 积分抵扣金额 运费 订单实付金额 订单编号 下单时间 支付时间 支付方式（可无） 备注 待收货 功能 自动确认收货倒计时（默认自发货时间起 10 天）（如客户未要求，默认不需要） 按钮 确认收货（高亮） 批量退款（分仅退款和退款退货，点击后底部出个弹窗，弹窗内容为商品列表，用于勾选需要退款的商品，选完提交后跳转表单页面，在表单页面选择退款的方式） 查看物流 退款状态（该按钮只显示在各个商品上，并且该商品已申请退款，点击跳转对应的退款详情页）（状态有 审核中 / 待上传物流信息 / 退款成功 / 商家已驳回 / 已撤回） 状态流转 交易完成（确认收货后流转） 详情展示内容 用户地址信息 各种商品信息（图片，名称，规格，单价，数量） 商品总金额 优惠金额 积分抵扣金额 运费 订单实付金额 订单编号 下单时间 支付时间 支付方式（可无） 发货时间 备注 交易完成 功能 无 按钮 立即评价（高亮）（根据产品需求是否展示） 查看物流 批量退款（分仅退款和退款退货，点击后底部出个弹窗，弹窗内容为商品列表，用于勾选需要退款的商品，选完提交后跳转表单页面，在表单页面选择退款的方式） 退款状态（该按钮只显示在各个商品上，并且该商品已申请退款，点击跳转对应的退款详情页）（状态有 审核中 / 待上传物流信息 / 退款成功 / 商家已驳回 / 已撤回） 状态流转 无 详情展示内容 用户地址信息 各种商品信息（图片，名称，规格，单价，数量） 商品总金额 优惠金额 积分抵扣金额 运费 订单实付金额 订单编号 下单时间 支付时间 支付方式（可无） 发货时间 收货时间 备注 交易关闭 功能 无 按钮 无 状态流转 无 详情展示内容 用户地址信息 各种商品信息（图片，名称，规格，单价，数量） 商品总金额 优惠金额 积分抵扣金额 运费 订单实付金额 订单编号 下单时间 备注 以下由上一状态决定是否显示 支付时间 支付方式（可无） 发货时间 收货时间 二、退款订单状态（仅退款和退款退货） 审核中（审核中有 2 种情况，第一种是用户提交申请后，第二种是用户上传物流信息后） 待上传物流信息(退款退货下显示，仅退款不显示) 退款成功 商家已驳回(商家可以在任意阶段驳回用户的申请) 已撤回 注意： 联系客服这个按钮不在按钮列表显示，统一加在退款详情页面内容中。 商家收到用户退货商品后，如要驳回，需自行联系用户，告知其退还货物订单号，前台页面不再展示相关订单信息。 订单列表需展示退款类型（退款退货/仅退款） 审核中 功能 无 按钮 撤回申请 状态流转 待上传物流信息（用户提交退款申请后流转） 退款成功（商家退款后流转） 已驳回（商家驳回用户申请后流转） 已撤回（用户撤回申请后流转） 详情展示内容 退款商品信息（图片，名称，规格，单价，数量） 退款方式 退款金额 备注 退款单号 申请时间 待上传物流信息（退款退货显示） 功能 无 按钮 上传物流 撤回申请 状态流转 审核中（用户上传物流信息后流转） 已撤回（用户撤回申请后流转） 退款成功 功能 无 按钮 无 状态流转 无 商家已驳回 功能 无 按钮 无 状态流转 无 已撤回 功能 无 按钮 无 状态流转 无 流程图","tags":[]},{"title":"复制","date":"2019-06-20T01:53:03.000Z","path":"2019/06/20/复制/","text":"使用document.execCommand(&quot;Copy&quot;);来实现把复制的内容复制到粘贴板 思路 创建 input 框，value 值为需要复制的内容，设置 readonly=”readonly”禁止唤起键盘 使用 getElementById 获取 input 框 调用.select()方法选中 input 框的内容（ios 中.select 方法无效） 最后调用 document.execCommand(“Copy”) 实现复制 具体代码（最初版）html: 123456&lt;input value=\"copy 的内容\" id=\"copy\" readonly=\"readonly\" style=\"opacity: 0; position: absolute\"/&gt; js（只适合安卓端）: 1234const urlLink = document.getElementById(\"copy\");urlLink.select();document.execCommand(\"copy\");message.success(\"分享链接已复制成功！\", 1); 遇到的问题及解决方案 如果不想显示 input 框，可以将 input 框的 opacity 属性设置为 0，在使用绝对定位使其脱离文档流。注意，不能将 input 框的 display 属性设置为 none 或将 visibility 设置为 hidden 或设置 disabled，这会导致复制失败 ie 之外的浏览器 document.execCommand(“copy”);这个必须在由用户操作触发的点击事件线程中执行，在 axios 异步的回调函数中执行是不允许的。解决的方案是使用 async 和 await，将异步的操作变为同步即可 ios 中无法使用.select()方法选中文字，需要重写选中文字的方法 1234567891011121314selectText = (textbox, startIndex, stopIndex) =&gt; &#123; if (textbox.createTextRange) &#123; //ie const range = textbox.createTextRange(); range.collapse(true); range.moveStart(\"character\", startIndex); //起始光标 range.moveEnd(\"character\", stopIndex - startIndex); //结束光标 range.select(); //不兼容苹果 &#125; else &#123; //firefox/chrome textbox.setSelectionRange(startIndex, stopIndex); textbox.focus(); &#125;&#125;; 具体代码（最终版，兼容双端）12345let urlLink = document.getElementById(\"urlCopy\");this.selectText(urlLink, 0, url.length);console.log(document.execCommand(\"copy\"), \"execCommand\");document.execCommand(\"Copy\");urlLink.blur(); 使用 react-copy-to-clipboard 插件实现文档地址： https://github.com/nkbt/react-copy-to-clipboard/ 具体代码 1234567import &#123; CopyToClipboard &#125; from \"react-copy-to-clipboard\";&lt;CopyToClipboard text=&#123;this.state.value&#125; onCopy=&#123;() =&gt; this.setState(&#123; copied: true &#125;)&#125;&gt; &lt;span&gt;Copy to clipboard with span&lt;/span&gt;&lt;/CopyToClipboard&gt;;","tags":[]},{"title":"移动端踩过的坑","date":"2019-06-19T10:29:31.000Z","path":"2019/06/19/移动端兼容/","text":"IOS new Date 中指定的字符串的格式为 new Date(“2018/04/27 11:11”)，其余格式需转化，例new Date((&quot;2018-04-27 11:11&quot;).replace(/-/g, &quot;/&quot;)) Safari 浏览器中的弹性滑动属性-webkit-overflow-scrolling: touch 会导致 z-index 属性失效，解决的方法是通过设置transform: translateZ(1px)，1px 中的 1 用来代表层级 Android 软键盘呼起会使 webview 高度变小，并且 fixed 定位元素会跟着键盘上移。解决的方法是通过 js 获取软键盘呼起前后的饰扣高度差，将 fixed 元素的 marginTop 设置为这个差值。具体代码： 1234567891011const height = document.body.offsetHeight; // 获取软键盘呼起前视图容器高度window.onresize = function() &#123; if (document.body.offsetHeight &lt; height) &#123; document.getElementById(\"footer\").style.marginTop = `$&#123;(height - document.body.offsetHeight) / 10&#125;rem`; document.getElementById(\"footer\").style.position = \"static\"; &#125; else &#123; document.getElementById(\"footer\").style.position = \"absolute\"; &#125;&#125;;","tags":[]},{"title":"下载文件到本地","date":"2019-06-19T10:29:31.000Z","path":"2019/06/19/下载文件/","text":"一、HTML5 原生 download 属性实现方法：&lt;a href=&quot;large.jpg&quot; download&gt;下载&lt;/a&gt;缺点： 兼容差，目前只兼容了 Chrome 文件需要是同源的，跨域资源会使 download 属性失效 二、使用 Blob 实现文件下载接口请求设置responseType: blob来使得返参为 blob 类型实现方法： 123456789101112download = (content, filename) =&gt; &#123; const eleLink = document.createElement(\"a\"); eleLink.download = filename; // 文件名 eleLink.style.display = \"none\"; var blob = new Blob([content]); // Blob二进制转换 eleLink.href = URL.createObjectURL(blob); // 二进制路径转换 // 触发点击 document.body.appendChild(eleLink); eleLink.click(); // 然后移除 document.body.removeChild(eleLink);&#125;; 三、生成截图并保存1.主要使用 html2canvas 库和 canvas2img 库。html2canvas(可通过 npm 安装): 文档地址：http://html2canvas.hertzen.com/ github 地址：https://github.com/niklasvh/html2canvas/ canvas2img(直接 copy 源码至项目): github 地址：https://github.com/hongru/canvas2image/ 2.使用方法 12345678910111213141516171819202122232425html2canvas(document.getElementById(\"view\"), &#123; // 这里是相应的配置，具体配置参考文档 useCORS: true // 是否支持跨域 scrollY: 0, // 出现偏移，且脱离文档流时使用&#125;).then(canvas =&gt; &#123; // canvas参数即为canvas const img = Canvas2Image.convertToImage(canvas); // 下载，兼容性不好，只支持Chrome document.body.appendChild(img); var a = document.createElement(\"a\"); // 创建一个单击事件 var event = new MouseEvent(\"click\"); // 将a的download属性设置为想要下载的图片名称 a.download = \"截图\"; a.href = img.src; //将img的src值设置为a.href属性，img.src为base64编码值 // 触发a的单击事件 a.dispatchEvent(event); // width: 300, // height: 300,&#125;); 注意：如果出现截图不完整，偏移等情况，这是由于定位使其脱离了文档流，可通过设置 scrollY：0 解决","tags":[]}]